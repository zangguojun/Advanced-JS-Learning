#### 1

```js
function a() {
  console.log(a, b, c);// undefined undefined undefined
  var a = 12, b = 13, c = 14
  function fn(a) {
    console.log(a, b, c);// 10 13 14
    a = 100
    c = 200
    console.log(a, b, c);// 100 13 200
  }
  b = fn(10)
  console.log(a, b, c);// 12 undefined 200 
}
a()
```

> 注意**私有变量**



#### 2

```js
function b() {
  var i = 0
  function A() {
    var i = 10
    function x() {
      console.log(i);
    }
    return x
  }
  var y = A()
  y() // 10
  function B() {
    var i = 20
    y()//10
  }
  B()
}
b()
```

> + 函数的作用域，也就是函数在哪声明
>
> + 函数自己的作用域与当前函数的作用域.......等的一条链子



#### 3

```js
function c() {
  var a = 1
  var obj = {
    'name': 'tom'
  }
  function fn() {
    var a2 = a
    obj2 = obj
    a2 = a
    obj2.name = 'jack'
  }
  fn()
  console.log(a, 1);
  console.log(obj, { name: 'jack' });
}
c()
```

>注意**私有变量**



#### 4

```js
function d() {
  var a = 1
  function fn(a) {
    console.log(a, '[Function: a]');
    var a = 2
    function a() { }
  }
  fn(a)
}
d()
```

>1. 初始化`this`指向
>2. 初始化实参集合（`arguments`）
>3. 形参赋值
>4. 变量提升，最后才做
>5. 代码执行



#### 5

```js
function e() {
  var a = 1
  function fn(a) {
    a()
    console.log(a, '[Function: a]');
    var a = 2
    console.log(a, 2);
    function a() {
      console.log(a, '[Function: a]');
    }
    console.log(a, 2);
  }
  fn(a)
  console.log(a, 1);
}
e()
```

> 同上
>
> + 如果在`全局`并没有声明块级作用域**（函数内部）**的函数，那么当执行到函数这行的时候，就不需要映射到`全局`



#### 6

```js
function h() {
  var foo = 'hello';
  (function (foo) {
    console.log(foo, 'hello');
    var foo = foo || 'world'
    console.log(foo, 'hello');
  })(foo)
  console.log(foo, 'hello');
}
h()
```

> `||`和`&&`
>
> `A||B`：如果A为真值，返回A的值，否则返回B的值
>
> `A&&B`：如果A为假值，返回A的值，否则返回B的值
>
> **同时出现**：`&&`的**优先级**高于`||`
>
> ```js
> function i() {
>   console.log(0 || false && [] || 10 && true || 20);
> }
> i()
> ```
>
> > **`||`和`&&`的使用都不是很严谨**
>
> ##### 拓展1(默认值)
>
> ```js
> function j() {
>   function func0(x = 1) {
>     console.log(x);
>   }
>   func0()
>   function func1(x) {
>     if (typeof z === 'undefined') x = 1
>     console.log(x);
>   }
>   func1()
>   function func2(x) {
>     x = x || 1;
>     /**
>      * 这样也可以，只不过不如上面准确
>      * 上面都是不传递赋值为默认值
>      * 这样写是不传值或者传递的值是假，都会赋值为more在
>      */
>     console.log(x);
>   }
>   func2()
> }
> j()
> ```
>
> ##### 拓展2(预防错误)
>
> ```js
> function k() {
>   function hello() {
>     console.log('hello');
>   }
>   function func1(callback) {
>     if (typeof callback === 'function') callback()
>   }
>   func1(hello())
>   function func2(callback) {
>     callback && callback()
>     /**
>      * 依然不严谨，一般我们默认要不然不传，要传一定要传递函数
>      */
>   }
>   func2(hello())
> }
> k()
> ```



#### 7

```js
function m() {
  (function AAA() {
    console.log(AAA, '[Function: AAA]');
    console.log(arguments.callee);
    console.log(arguments.callee.caller);
    A = 1000
    console.log(AAA);
  })();
  console.log(AAA);// ReferenceError: AAA is not defined
}
m()
```

>**自执行函数、函数表达式的函数、回调函数等都是匿名函数**（可以理解为**私有变量**），只不过为了保证好的习惯，要**具名化**，这个名字的特点有：
>
>+ 这个名字**只能在函数内部被调用**（可以用作**递归**），`函数外面无法调用`，这样做是为了避免使用在**严格模式下不支持**的`arguments.callee()`
>
>+ 这个名字的变量在函数**内部的值不能被修改的**
>
>+ 但是如果是基于`var/const/let/function`等重复操作处理，**会把这个具名化的名字改为正常的私有变量**，也就是**该名字**被覆盖了，不代表当前函数
>
>  + ```js
>    function n1() {
>      (function AAA() {
>        let AAA = 1000;
>        console.log(AAA);
>      })();
>    }
>    n1()
>    ```
>
>  + ```js
>    function n2() {
>      (function AAA() {
>        var AAA = 1000
>        console.log(AAA);
>      })();
>    }
>    n2()
>    ```
>
>  + ```js
>    function n3() {
>      (function AAA() {
>        function AAA() {
>          console.log('AAA');
>        }
>        console.log(AAA);
>        AAA = 1000
>        console.log(AAA);
>      })();
>    }
>    n3()
>    ```
>
>  + 而且如果在之前调用了`AAA`就会报错`ReferenceError: Cannot access 'AAA' before initialization`，因为`let`**之前**以及**之后**都不能有任何`const/var/function`的语句
>
>  + ```js
>    function o() {
>      (function AAA() {
>        console.log(AAA);// ReferenceError: Cannot access 'AAA' before initialization
>        let AAA = 1000;
>        console.log(AAA);
>      })();
>    }
>    o()
>    ```
>
>  + `衍生let`，`ReferenceError: Cannot access 'AAA' before initialization`是在**函数执行期间**的报错，并不是像`let`重复定义变量，导致的报错`SyntaxError: Identifier 'a' has already been declared`，它是在**词法解析**的时候报错
