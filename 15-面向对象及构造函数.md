## 面向对象

> `OOP`：面向对象设计
>
> `POP`：面向过程
>
> **HTML、CSS属于标记语言，LESS、SASS等是CSS预处理器，是面向对象的语言**

```js
function a() {
  function Fun() {
  }
  let a = Fun()
  console.log(a, undefined);
  let f = new Fun()
  console.log(f, 'Fun {}');
}
a()
```

> 当**普通函数**执行和当作**构造函数**执行的区别

```js
function a() {
  function Fun() {
  }
  let a = Fun()
  console.log(a, undefined);
  let f = new Fun()
  console.log(f, 'Fun {}');
}
a()
```

```js
function b() {
  function Func(x, y) {
    let num = x + y;
    this.x = x;
    this.y = y;
  }
  let f1 = Func(10, 20)
  console.log(f1, undefined);
  console.log(this.x, 10);
}
b()
```

> **普通函数执行的区别**
>
> 创建`ECStack`、`VO`
>
> 创建`EC(G)`并进栈
>
> > 创建`VO(G)`
> >
> > 初始化`this`，`window`
> >
> > 变量提升：`function Fnnc(){}`
> >
> > 代码执行：
> >
> > ~~function Fnnc(){}~~
> >
> > `let f1 = Func(10, 20)`
> >
> > 创建`EC(FUNC)`并进栈
> >
> > > 创建`AO(FUNC)`
> > >
> > > 初始化作用域链：`<EC(FUNC)>, EC(G)`
> > >
> > > 初始化`this`，`window`
> > >
> > > 初始化实参集合：`arguments ，arguments[0] = 10，arguments[1] = 20`
> > >
> > > 形参赋值：`x = 10，y = 20`
> > >
> > > 变量提升：无
> > >
> > > 代码执行：
> > >
> > > `let num = x + y` ==>`AO(FUNC)`新增`num = 30`
> > >
> > >   `this.x = x` ==>`window`新增`x = 10`
> > >
> > >   `this.y = y` ==>`window`新增`y = 20`
> > >
> > > 返回值：
> > >
> > > 没有`return`，默认返回`undefined`
> >
> > `EC(FUNC)`出栈释放
> >
> > `console.log(f1, undefined)` ==> `undefined`
> >
> >  `console.log(this.x, 10)`==>`10`
>
> `EC(G)`出栈释放

```js
function c() {
  function Func(x, y) {
    let num = x + y;
    this.x = x;
    this.y = y;
  }
  let f1 = new Func(10, 20)
  console.log(f1, 'Func { x: 10, y: 20 }');
  console.log(this.x, undefined);
}
c()
```

>**构造函数执行的区别**
>
>创建`ECStack`、`VO`
>
>创建`EC(G)`并进栈
>
>> 创建`VO(G)`
>>
>> 初始化`this`，`window`
>>
>> 变量提升：`function Fnnc(){}`
>>
>> 代码执行：
>>
>> ~~function Fnnc(){}~~
>>
>> `let f1 = Func(10, 20)`
>>
>> 创建`EC(FUNC)`并进栈
>>
>> > 创建`AO(FUNC)`
>> >
>> > 初始化作用域链：`<EC(FUNC)>, EC(G)`
>> >
>> > ---------
>> >
>> > **区别1、2**
>> >
>> > + **首先默认创建一个对象**（`这个对象就是当前类的实例`），假如堆内存空间为`AAAFFF000`
>> > + **让当前上下文中的`this`指向这个对象**
>> >
>> > -----
>> >
>> > 初始化`this`，**当前创建的实例对象**
>> >
>> > 初始化实参集合：`arguments ，arguments[0] = 10，arguments[1] = 20`
>> >
>> > 形参赋值：`x = 10，y = 20`
>> >
>> > 变量提升：无
>> >
>> > 代码执行：
>> >
>> > ----
>> >
>> > **因为区别1、2，而出现差异**
>> >
>> > `let num = x + y` ==>`AO(FUNC)私有上下文`新增`num = 30`
>> >
>> >   `this.x = x` ==>`默认创建的实例对象AAAFFF000`新增`x = 10`
>> >
>> >   `this.y = y` ==>`默认创建的实例对象AAAFFF000`新增`y = 20` 
>> >
>> > ==！这里的num只是AO(FUNC)中的私有上下文里面的变量，**只有`this.xxx`才是实例对象里面的变量**，他们没有直接关系！==
>> >
>> > 返回值：
>> >
>> > **区别3**
>> >
>> > + **在函数没有返回值的情况下，默认会把创建的实例对象返回**
>> >   + 如果函数中有返回值
>> >     + **如果返回值为基本数据类型值，返回默认创建的实例对象`AAAFFF000`**
>> >     + **如果返回值为引用值，该返回值会替换默认返回的实例对象，而会返回该引用值**
>>
>> `EC(FUNC)`出栈释放
>>
>> `console.log(f1, undefined)` ==> `undefined`
>>
>>  `console.log(this.x, 10)`==>`undefined`，因为此时的`this`是`window`
>
>`EC(G)`出栈释放

> 每一个对象（包含实例对象）都有很多属性和方法，在**自己堆内存**中存储的都是**私有**的属性和方法，基于`__proto__`原型链查找类`prototype`原型上的都是共有的属性和方法，那么如何判断是私有还是共有的属性或者方法呢？
>
> + `obj.hasOwnPrototype(属性/方法)`：**检测是不是私有的属性或者方法**
>
> + `属性/方法 in 对象`：**检测是不是它的属性（不管共有还是私有）**
>
>   + ```js
>     function d() {
>       let obj = {
>         name: 'bu',
>         getName() {
>           return name
>         }
>       }
>       console.log(obj.hasOwnProperty('name'), true);
>       console.log(obj.hasOwnProperty('getName'), true);
>       console.log(obj.hasOwnProperty('toString'), false);
>       console.log('name' in obj, true);
>       console.log('getName' in obj, true);
>       console.log('toString' in obj, true);
>     }
>     d()
>     ```



