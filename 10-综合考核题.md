#### 1

```js
let arr = [10.18, 0, 10, 25, 23]
arr = arr.map(parseInt)
console.log(arr);
```

> ```js
> // 10.18 0 10
> // 0     1 NaN
> // 10    2 2
> // 25    3 2
> // 23    4 11
> ```
>
> `radix`取：`0，[2, 36]`



#### 2

```js
var a = 10, b = 11, c = 12
function test(a) {
  a = 1     // => EC(a)私有
  var b = 2 // => EC(a)私有
  c = 3     // => EC(G)拥有
}
test(10)
console.log(a, b, c);
// 10 11 3
```



#### 3

```js
var a = 4
function b(x, y, a) {
  console.log(a, 3);
  arguments[2] = 10
  console.log(a, 10);
}
a = b(1, 2, 3)
console.log(a, undefined);
```

> 初始化`arguments`：**当函数中有处理`arguments`的步骤**，就需要考虑初始化`arguments`，`arguments`是函数内置实参集合，是一个类数组，形如`{0: 1,1: 2, 2: 3,length: 3}`
>
> + **在JS的非严格模式下**，函数中初始化`arguments`和形参赋值完成后， 浏览器会按照形参和`arguments`中的每一项建立**双向绑定（映射关系）**
>
> + **在JS的严格模式下**，并不会做任何操作
>
>   + ```js
>     var a = 4
>     function b(x, y, a) {
>       'use strict'
>       console.log(a, 3);
>       arguments[2] = 10
>       console.log(a, 3);
>     }
>     a = b(1, 2, 3)
>     console.log(a, undefined);
>     ```
>
>   
>
> **注意**：如果在参数传值中，没有传完整，那么`arguments`接收的**也是不完整的参数**，而且在之后**不会再改变**，这样`arguments`和参数传值**就没法一一对应**
>
> ```js
> function funcA(x, y, z) {
>   x = 100
>   console.log(arguments[0], 100);
> 
>   arguments[1] = 200
>   console.log(y, 200);
> 
>   z = 300
>   console.log(arguments[2], undefined);
> }
> 
> function funcB(x, y, z) {
>   x = 100
>   console.log(arguments[0], 100);
> 
>   arguments[1] = 200
>   console.log(y, 200);
> 
>   arguments[2] = 300
>   console.log(z, undefined);
> }
> funcA(10, 20)
> funcB(10, 20)
> ```
>
> > **实参集合和形参双向绑定（映射关系）**
> >
> > `x -> arguments[0]`
> >
> > `y -> arguments[1]`
> >
> > `z -> 没有，arguments只有两项`



#### 4

```js
{
  function foo() {}//*
  foo = 1
}
console.log(foo, '[Function: foo]');
```

> ##### **只考虑新版本浏览器，因为老版本浏览器，没有块级作用域**
>
> + **什么时候只是声明`let`和`function`？**
>   + **除函数题以外的大括号内**的`var`和`function`都会声明，新版本的浏览器不会定义函数。
> + **什么时候有块级作用域**
>   + 在代码执行的阶段，发现**除函数题以外的大括号内**有`let/const/function`，就会形成块级作用域
> + **标\*的部分**，虽然然此时的foo是私有的，但是为了兼容`ES3`，【本来在ES6想直接不管块级作用域里面的东西，即`不声明var和不声明也不定义function`，但是最终妥协了，折中处理了，`让var和function只是声明，function不定义`】，`foo`在全局中已经声明过，浏览器会把这行代码之前对`foo`的操作（**包含变量提升时候做的操作**）映射到全局一份（即，当再次遇到`function`函数块的时候，会把当前`foo`的值赋值给全局的`foo`）

```js

{
  function foo() {}
  foo = 1
  function foo() {}
}
console.log(foo, 1);

```

> `foo`在全局中已经声明过，浏览器会把这行代码之前对`foo`的操作（包含变量提升时候做的操作，**不管类型有没有变化（如上是将`function`变成了`number`）**）映射到全局一份
>
> 所以**全局foo**的状态：`全局下声明` =》`遇到块级第一个foo，将全局foo赋值为变量提升时的foo（即，块级第二个foo）`=》`遇到块级第二个foo，将全局foo赋值为1`
>
> **也可以理解为状态只改变一次，也就是以最后一个foo函数为准**

```js
console.log(foo, undefined);
{
  function foo() {}
  foo = 1
  function foo() {}
  foo = 2
}
console.log(foo, 1);
```





```js
'use strict'
{
  function foo() {}
  foo = 1
  function foo() {}
}
console.log(foo, 1);
```

> **严格模式**下，会报错`SyntaxError: Identifier 'foo' has already been declared`



#### 5

```js
var a = 9
function fn() {
  a = 0
  return function (b) {
    return b + a++
  }
}
var f = fn()
console.log(f(5), 5);
console.log(fn()(5), 5);
console.log(f(5), 6);
console.log(a, 2);
```

> 注意闭包



#### 6

```js
var test = (function (i) {
  return function () {
    console.log(i *= 2, 4);
  }
})(2)
test(5)
```

> **自执行函数**返回一个函数，此时`test(5)`中的实参没能传递给形参，但是**`arguments`依然接收到了实参5**



#### 7

```js
var x = 5, y = 6
function func() {
  x += y
  func = function (y) {
    console.log(y + --x, 13);
  }
  console.log(x, y); // 11 6
}
func(4)
func(3)
console.log(x, y); // 10 6
```

> 注意`私有变量`和`全局变量`



#### 8

```js
function fun(n, o) {
  console.log(o);
  return {
    fun: function (m) {
      return fun(m, n)
    }
  }
}
var c = fun(0).fun(1)
// undefined 0 {fun: function(m){return fun(m, n)}}
// ---- o: 1 n:1
c.fun(2)
// 1 {fun: function(m){return fun(m, n)}}
c.fun(3)
// 1 {fun: function(m){return fun(m, n)}}
```

> 对象里面的`func`和变量`func`并不相同