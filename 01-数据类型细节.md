## JS的数据类型
- 基本数据类型
- 引用数据类型
  - object
    - 普通对象
    - 数组对象
    - 正则对象
    - 日期对象
    - Math对象
  - function
---

### 数据类型检测
- typeof
- instanceof
- constructor
- Object.prototype.toString.call

### `typeof`
> 返回当前值的数据类型
- 返回值都是字符串

  - ```js
    let a = typeof typeof typeof [12]
    console.log(a);
    ```

- 局限性
  - `typeof null` 为 `object`
  - 不能细分对象类型，只能识别出function



### String类型

#### 其他数据类型转成String

先调用`valueOf()`，在调用`toString()`



### Boolean类型

#### 其他数据类型转成Boolean

##### 强转换（基于底层机制转换）`Boolean()`

- 直接调用浏览器底层的机制

+ `0`、`NaN`、`null`、`undefined`、`''` 为`false`，其他全为`true`
+ 一些隐式转换都是基于**Boolean()**完成的
  - `!0`，`!`
  - 数字运算，`10 - true`
  - ~~逻辑运算，`true == 数字`~~不是，此时是`Boolean`转`Number`



### Number类型

#### NaN
  > 不是一个有效数字
+ NaN和任何值都不相等，包括自己
+ `NaN`进行`+ - * / 等数字运算`都还是`NaN`

#### isNaN
  > 如果处理的值**不是数字**，需要先`隐式`转换（`Number()`）为数字，再检测这个值是否为有效数字，如果不是有效数字返回`true`，否则返回`false`
  >
  > + `isNaN(NaN)` 为 `true`
```js
let b = parseFloat('left:20px')
if (b === 200) {
  console.log(200);
} else if (b === NaN) {
  console.log(NaN);
} else if (typeof res === 'number') {
  console.log('number');
} else {
  console.log('Invalid Number');
}
```

#### 其他数据类型转成Number

##### 强转换（基于底层机制转换）`Number()`

- 直接调用浏览器底层的机制
  - `true -- 1`  
  - `false -- 0`
  - `null -- 0`，虽然`typeof null`为`object`，但是`null`只是**空对象指针**，所以结果`0`
  - `undefined -- NaN`
  - `特殊运算`
    - `[] -- 0`，其实是`[]`转换成`''`，再转换成`0`
    - `[1] -- 1`，其实是`[1]`转换成`'1'`，再转换成`1`
    - `{} -- NaN`，其实是`{}`转换成`'[object Object]'`，再转换成`NaN`
  - `字符串中必须保证全部为有效数字（空白串只能出现再首部和尾部），否则为NaN`
    - `'' -- 0`
    - `' ' -- 0`
    - **空白串**`Number('\t\v\f10\r\n\x0d\x0a\u2028\u2029')`为`10`
      - `' '`：空格
      - `\r \x0d`：回车，光标到本行行首
      - `\n \x0a`：换行，光标到下行行首
      - `\t`：水平制表符
      - `\v`：垂直制表符
      - `\f`：换页符
      - `\u2028`：行分隔符
      - `\u2029`：段分隔符
- 一些隐式转换都是基于**Number()**完成的
  - isNaN，`isNaN('12px')`

  - 数字运算，`'12px' - 10`

    - ```js
      let b = '10'
      console.log(+ b, 10);
      console.log(++b, 11);
      console.log(b++, 11);
      console.log(b, 12);
      ```

  - 逻辑运算，`字符串 == 数字`

##### 弱转换（基于一些额外的方法）`parseInt()、parseFloat()`

- `parseInt`：如果处理的值**不是字符串**，需要先转换为字符串，再进行处理，如果没找到任意一个数字，则返回`NaN`

```js
console.log(parseInt(''), NaN);
console.log(parseInt(null), NaN);
console.log(parseInt(undefined), NaN);
console.log(parseInt('12px'), 12);
console.log(parseInt('1.2px'), 1);
console.log(parseFloat('1.2px'), 1.2);
console.log(Number(null), 0);
console.log(Number(undefined), NaN);
console.log(Number(true), 1);
console.log(Number(false), 0);
console.log(Number(''), 0);
console.log(Number(' '), 0);
console.log(Number('12 '), 12);
console.log(Number(' \t\v\f0\r\n\x0d\x0a\u2028\u2029'), 0);
console.log(Number('12px'), NaN);
console.log(isNaN(""), false);
console.log(isNaN(NaN), true);
console.log(isNaN(null), false);
console.log(isNaN(undefined), true);
console.log(isNaN('null'), true);
```



### `运算符 == ` 比较规律

> 1. 首先，**把两边的JS表达式执行**
> 2. `对象 == 字符串`，**对象转换成字符串**。剩下两边不同类型，**都转成数字类型做比较**
> 3. `特殊`
>    1. `null == undefined`，除了自己，和其他值都不相等
>       + 为什么`0 == null`为`false`？
>         + 可以理解为`0`是一定会被分配到栈内存中的，但是`null`表示`未分配内存`
>    2. `NaN`与任何值都不相等，包括自己

##### 例子1：

```js
[10] == '10' //true
```



### `运算符 == ` 比较规律

> `类型`和`值`必须**都相等**



### `运算符 + ` 规律

> 没有遇到**字符串和对象**，**就全部转换成数字相加**
>
> 为什么对象也会影响？
>
> + 因为`+`会让对象先转换成`字符串`，才能转成`数字`，可以想象成**没有来的及转成数字类型**

##### 例子1：

```js
console.log(1 + [] + 2, '12');
```



### `{}`的多种意义

> + 对象
>
> + 代码块（块作用域）
>
>   + ```js
>     {
>         var a = 1
>     }
>     ```



### JS中对象的属性名

>  ~~普通对象的属性名只能是`字符串`？~~
>
> + 不确定，有人理解是可以为基本数据类型，包括`Symbol`以及`BigInt`
>
> + 我的理解是，**内部存储为字符串**，但是如果该**属性名**很**像**成**其他基本数据类型**，比如属性名为 
>   + `String 类型 'null' 像 Null 类型 null`
>   + `String 类型 'undefined' 像 Undefined 类型 undefined`
>   + `String 类型 '1' 像 Number 类型 1`
>
>   + 那么**像这个基本数据类型的值**也能进行索引

```js
var a = {}
var b = '0'
var c = 0
a[b] = 'bu'
a[c] = 'chi'
console.log(a[b], 'chi');

var a = {}
var b = Symbol('1')
var c = Symbol('1')
a[b] = 'bu'
a[c] = 'chi'
console.log(a[b], 'bu');

var a = {}
var b = {n:'1'}
var c = {n:'2'}
a[b] = 'bu'
a[c] = 'chi'
console.log(a[b], 'chi');
```

