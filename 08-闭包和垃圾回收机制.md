### `let`和`var`的区别

> + `var和function`存在变量提升，`let和const`不会
>
> + `var和function`在VOG中，会与GO建立双向绑定，`let和const`不会





### 函数执行原理 + 闭包（当前上下文有没有东西被当前上下文以外的东西占用）

> + 形成私有上下文（ECFN）
> + 进栈执行
> + 形成私有变量对象（AOFN）
> + 一系列初始化
> + 代码执行 =》 执行完毕
> + 分两种情况
>   1. 正常情况，私有上下文会出栈，并且被释放以节约栈内存的空间。
>   2. 特殊情况，**如果当前私有上下文中的某个对象**被当前上下文以外的东西占用，则私有上下文不会再出栈释放，**也就形成了不能被销毁的上下文，即闭包**



### 函数上下文与闭包

> 1. **保护**（防止全局变量污染）：划分一个独立的代码执行区域，在这个区域中可以存储私有变量，而和其他区域中的变量不会有任何的冲突
> 2. **保存**：如果私有上下文未被销毁，那么存储的私有变量的值也不会被销毁，可以被下层上下文调取
> 3. 把函数执行形成的私有上下文产生的**保护和保存**的**机制**，称为闭包





### 浏览器垃圾回收机制（浏览器自动操作）

> 1. IE浏览器是**基于计数器**
>    - 创建的内存每被引用一次，则计数器加一，每移除引用一次，则减一，当减为零时，浏览器会把内存释放掉
> 2. 谷歌浏览器等是**基于引用查找**
>    + 对于开辟的**堆内存**，浏览器**默认**会在空闲的时候，查找所有内存的引用，把那些**不被引用的内存释放掉**
>    + 对于开辟的**栈内存**（也就是**上下文EC**），正常情况下会在代码执行完都会出栈释放。特殊情况下，如果遇到上下文中的**对象**被外部占用，则不会被释放
> 3. 真实项目中，**内存泄漏问题**
>    - **某些情况会导致计数器规则出现问题**，造成很多内存不能被释放，从而产生了内存泄露问题。
>    - 查找引用规则如果**形成相互引用**，也会造成内存泄漏问题
>    - 综上，**IE下的内存泄漏比较严重**，chrome下的内存泄露不严重







```JS
let x = 1
function A(y) {
  let x = 2
  function B(z) {
    console.log(x + y + z, 7);
  }
  return B
}
let C = A(2)
C(3)
```

> **这么让EC(A)出栈释放？**
>
> `C = null`



![闭包](https://cdn.jsdelivr.net/gh/zangguojun/PicGo/20210531140904.png)

