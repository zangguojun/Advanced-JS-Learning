## 谈谈你对闭包的理解，以及在项目中的应用

#### 1、闭包是什么？

> 引申出来堆栈、EC、AO、VO、Scope等

#### 2、闭包的作用

**浏览器加载页面会把代码放到栈内存（也就是`ECStack`）中执行，函数进栈执行会产生一个私有的上下文（也就是`EC`），此上下文能保护里面的私有变量（也就是`AO`）不受外界干扰，并且如果当前上下文中的某些内容被上下文以外的内容所占用，当前上下文是不会出栈释放的，这样可以保存住里面私有变量，所以我认为闭包是一种保存和保护内部私有变量的机制**

#### 3、闭包在真实项目中的应用场景

1、我会基于闭包把自己编写的模块内容包起来，这样自己编写的代码都是私有的，**防止和全局变量或者别人的代码冲突**，**这一点是利用的是闭包的保护机制**

2、在没有使用`let`之前，我们**循环处理事件绑定**，在事件触发需要用到索引值的时候，我们会**基于闭包保存每一轮循环的索引值**，这样就能实现我们的需求，只不过现在都是基于`let`来完成，因为`let`会产生块级作用域来保存需要的内存（机制和闭包类似）

#### 4、闭包所带来的问题

但是不建议滥用闭包，**因为会形成不被释放发上下文，是占用内存空间的，滥用会导致页面渲染变慢**，所以更合理的应用闭包

#### 5、由闭包引发的高阶编程技巧

除了这些传统的业务开发中会应用闭包，我之前在研究别人源码和自己写一些小插件的时候，**往往也会用利用一些JS高级编程技巧，他们底层机制其实就是闭包**。例如，**惰性函数、柯里化函数、compose函数**

#### 6、闭包在框架源码的应用



#### 7、闭包在自己写类库、插件的应用

## 惰性函数

> **兼容性**
>
> + `DOM0`事件绑定：`xxx.onclick = function(){}`
>
> + `DOM2`事件绑定：`xxx.addEventListener('click',function(){})`，只不过不兼容`IE6/7/8`，低版本中式基于`xxx.attachEvent('click',function(){})`

#### 处理兼容性

```js
function observerEvent(element, type, func) {
  if (element.addEventListener) {
    element.addEventListener(type, func)
  } else if (element.attachEvent) {
    element.attachEvent(type, func)
  } else {
    element[`on${type}`] = func
  }
}
observerEvent(element, 'click', function () {
  console.log(element.addEventListener, element.attachEvent, [`on${type}`]);
})
```

> 这种写法虽然能实现需求，但是每次都必须做相同的兼容判断，**实际上只需要做一次就已经直到它的兼容性了**

#### 改良

```js
function observerEvent(element, type, func) {
  if (element.addEventListener) {
    observerEvent = function () {
      element.addEventListener(element, type, func)
    }
  } else if (element.attachEvent) {
    observerEvent = function () {
      element.attachEvent(type, func)
    }
  } else {
    observerEvent = function () {
      element[`on${type}`] = func
    }
  }
}
observerEvent(element, 'click', function () {
  console.log(element.addEventListener, element.attachEvent, [`on${type}`]);
})
```

> 第一次执行`observerEvent`，根据兼容性判断，重构了这个函数，`重构后的函数不需要进行兼容性验证`，最后**需要执行重构后的方法**，实现`第一次`事件绑定。在之后，原`observerEvent`函数的堆就会被销毁，但是原`observerEvent`的上下文不会被释放，只是上下文中的`VO/AO`的`observerEvent`变量会指向**新的地址**



## 单例设计模式

> **框架开发无需使用单例处理**，单例模式式最早的模块开发思想，与如今的`CMD`、`AMD`、`CommonJS`、`ES6Module`思路一致

#### 1、无模块开发

```js
function b() {
  (function () {
    function queryData() { }
    function getElement() { }
    window.getElement = getElement
  })()
  console.log(getElement);
}
b()
```



#### 2、原始模块化开发

```js
function c() {
  let weatherModule = (function () {
    function queryData() { }
    function getElement() { }
    return {
      getElement
    }
  })()
  console.log(weatherModule.getElement);
}
c()
```

> 此时的`weatherModule`除了是全局变量、模块名称、对象名，更专业的叫法是：**命名空间**，这样的单例设计模式就是**把描述相同的事务或者相同板块中的属性和方法归拢到相同的命名空间，实现分组管理**。既可以避免全局变量污染，也可以实现模块间相互调用。



#### 3、命令模式

```js
function d() {
  let weatherModule = (function () {
    function queryData() { }
    function getElement() { }
    function bindHTML() { }
    function handleEvent() { }
    return {
      init() {
        queryData();
        getElement();
        bindHTML();
        handleEvent();
      }
    }
  })()
  weatherModule.init()
}
d()
```

> 在单例设计模式的基础上，增加一个命令模式，`init`作为当前模块业务的入口，以后只需要执行`weatherModule.init()`，我们在`init()`中根据业务代码需求，把编写的方法按照顺序依次调用执行即可。