#### 1

```js
function a() {
  console.log(!(!'Number(undefined)'), true);
  // true
  console.log(isNaN(parseInt(new Date())) + Number([1]) + typeof undefined, '2undefined');
  // true + 1 + 'undefined'
  console.log(Boolean(Number('')) + !isNaN(Number(null)) + Boolean('parseInt[]') + typeof !(null), '2boolean');
  // false + true + true + 'boolean'
  console.log(parseFloat('1.6px') + parseInt('1.2px') + typeof parseInt(null), '2.6number');
  // 1.6 + 1 + 'number'
  console.log(isNaN(Number(!!Number(parseInt('0.8')))), false);
  // 0 true 1 false
  console.log(!typeof parseFloat('0'), true);
  // 0 'number' true
  console.log(typeof 'parseInt(null)' + 12 + !!Number(NaN), 'string12false');
  // 'string' + 12 + false
  console.log(!typeof (isNaN('')) + parseInt(NaN), NaN);
  // 0 false 'boolean' false + NaN
  console.log(typeof !parseInt(null) + !isNaN(null), 'booleantrue');
  // NaN true 'boolean' + true
}
// a()
```



#### 2

```js
function b() {
  var x = 1
  function func(x, y = function anonymous1() { x = 2 }) {
    x = 3
    y()
    console.log(x, 2);
  }
  func(5)
  console.log(x, 1);
}
b()
```

> **写一下完整的流程**
>
> 创建EC(G)，入栈
>
> > + 创建VO(G)
> >
> > + 变量提升`var x  function func(){}  [[scope]]:EC(G)`
> >
> > - 代码执行
> >
> > `x = 1`
> >
> > 创建EC(FUNC)，入栈
> >
> > > + 创建AO(FUNC)
> > >
> > > + 初始化作用域链`<EC(FUNC)，EC(G)>`
> > >
> > > + 初始化`this`
> > > + 初始化实参集合`arguments`:`arguments[0] = 5 `
> > > + 形参赋值，`x = 5 y = function anonymous1() { x = 2 }   [[scope]]:EC(FUNC)` 
> > > + 变量提升，`x`已经申明
> > > + 代码执行
> > >
> > > `x = 3`
> > >
> > > `y()`
> > >
> > > 创建EC(Y)，入栈
> > >
> > > > + 创建AO(Y)
> > > > + 初始化作用域链`<EC(Y),EC(FUNC)>`
> > > > + 初始化`this`
> > > > + 初始化实参集合`arguments`-----
> > > > + 形参赋值-----
> > > > + 变量提升-----
> > > > + 代码执行
> > > >
> > > > `x = 2`沿着作用域链，发现在EC(FUNC)中存在`x`，将EC(FUNC)中的x赋值为2
> > >
> > > EC(Y)出栈
> > >
> > > `console.log(x)`打印EC(FUNC)中的x为**2**
> >
> > EC(FUNC)出栈
> >
> > `console.log(x)`打印EC(G)中的x为**1**
>
> EC(G)出栈

#### 浏览器`BT`机制

> 如果在第4行的`x`前面加上`var`

```js
function c() {
  var x = 1
  function func(x, y = function anonymous1() { x = 2 }) {
    var x = 3
    y()
    console.log(x, 3);
  }
  func(5)
  console.log(x, 1);
}
c()
```

> 上面代码在进行chrome调试的时候，函数上下文中居然出现了`Block`上下文？？查阅之后，这个居然是浏览器的机制，下面几种情况，会出现这个块级上下文
>
> + 如果设置了形参变量，并且部分形参变量**设置了ES6中的形参赋值默认值**，并且**形参变量在代码块里被重新申明**，就会多一个新的Block上下文。
>
>   + ```js
>     function func(x, y = 1) {
>         var x = 2
>         var z = 2
>     }
>     func(1, 2)
>     ```
>
> + 形如上式，调用`func`就会出现`Block`上下文，并且`x`会出现在上下文里面
>
> + **其实也很容易理解，它把形参当作私有上下文，把大括号里面的当作块级上下文，并且当生成新的块级作用域后，在块级上下文的形参赋值过程中，会把形参中有而且代码块中也重复声明的变量 从形参中拷贝一份到块级上下文，如果在私有函数的形参赋值中没有的变量，赋值为`undefined`**
>
>   + 未执行`var x = 2`行 的调试状态
>
> ![image-20210604191110484](https://cdn.jsdelivr.net/gh/zangguojun/PicGo/20210604191117.png)
>
> + 发现了`z`并没有在私有上下文
>   + 执行`var x = 2`行的调试状态
>
> ![image-20210604192718189](https://cdn.jsdelivr.net/gh/zangguojun/PicGo/20210604192718.png)
>
> + **发现`x`在块级上下文中更新，并没有在函数私有上下文更新，而且下面这个例子也说明了，只有在形参赋值中的操作，才会更新到私有上下文，并且只有在形参赋值中的`log`，打印出来的`x`才会读取私有变量的值，否则读取块级上下文的值**

**观察第19行的注释，好家伙！调试工具都被骗到了。它这里还是说`log`为`2`，殊不知控制台已经打出`3`了**

![image-20210604192354037](https://cdn.jsdelivr.net/gh/zangguojun/PicGo/20210604192354.png)

```js
function d() {
  var x = 1
  function func(x, y = function anonymous1() { x = 2 }) {
    var x = 3
    var y = function anonymous2() { x = 4 }
    y()
    console.log(x, 4);
  }
  func(5)
  console.log(x, 1);
}
d()
```

> **上面的代码又能总结一条规则：如果在块级作用域中`拦截`了`y`，那么此时`y`的上下文为块级的上下文，最后修改的是块级作用域的`x`值，而且此时的`anonymous2`的作用域链为`<EC(anonymous2), EC(Block)>`，块级上下文的作用域链在谷歌浏览器的调试工具中是`<EC(Block),EC(FUNC)>`，`说明这个Block和func并不是兄弟关系，并不是父子关系`**





## `var/let/const`的区别















