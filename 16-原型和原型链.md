## 原型和原型链

> **函数数据类型**：*类（内置类【Array、String、Number、Boolean等】/自定义类）*==都是Function的实例==
>
> **对象数据类型**：*普通对象*，**函数对象**，*实例对象*，**函数的prototype对象**，数组对象，正则对象，日期对象==都是Object的实例==
>
> > 函数里不光存储函数体的`字符串`，还存储了
> >
> > + ``length`：函数*形参*长度
> > + `name`：函数名
> > + `prototype`：原型
> > + `__proto__`：原型链
> > + `[[Scope]]`：作用域链
> >
> > ---
> >
> > + `arguments`：函数*实参*集合
> > + `caller`：
> >
> > **上述两个基本不用**
> >
> > ---

```js
function a() {
  function Fn() {
    this.x = 100;
    this.y = 200;
    this.getX = function () {
      console.log(this.x);
    }
  }
  let f1 = new Fn()
  console.log(f1);
}
a()
```

> 1. 每一个函数（除ES6箭头函数外）都有一个内置的属性，`prototype`，**原型属性**，属性值是一个对象，在对象中会存储当前类的公共属性和方法
>    + **对于普通函数来说没用，但是对于函数类来说才有作用，可以把属性或方法放到`prototype`中，供类的实例调用**
> 2. `prototype`是一个对象，存储在堆内存中，*如果是浏览器为其默认开辟的堆内存*，会存在一个内置的属性：`construct`构造函数，**属性值就是当前类本身**
> 3. **每一个对象都有一个内置属性：`__proto__`，原型链属性，属性值是当前实例所对应类的`prototype`对象函数的**
>
> **因为`函数.prototype`是一个普通的对象，并且所有对象都是`Object`的实例，所以所有函数的`prototype`的`__proto__`都指向`Object`的`prototype`**
>
> `Object`的`prototype`也是一个普通对象，所以它也是`Object`的一个实例，按理论上来说，它的`__proto__`应该也指向`Object.prototype`，也就是指向自己，这样没有意义，所以`Object.__proto__`为`null`



### 原型链

```js
function b() {
  function Fn() {
    this.x = 100;
    this.y = 200;
    this.getX = function () {
      console.log(this.x);
    }
  }
  Fn.prototype.getX = function () {
    console.log(this.x);
  }
  Fn.prototype.getY = function () {
    console.log(this.y);
  }
  let f1 = new Fn()
  let f2 = new Fn()
  console.log(f1.getX === f2.getX, false);
  console.log(f1.getY === f2.getY, true);
  console.log(f1.__proto__.getY === Fn.prototype.getY, true);
  console.log(f1.__proto__.getX === f2.getX, false);
  console.log(f1.getX === Fn.prototype.getX, false);
  console.log(f1.constructor, Fn);
  console.log(Fn.prototype.__proto__.constructor, Object);
  f1.getX()
  f1.__proto__.getX()
}
b()
```

> 原型链机制：调用当前实例对象的某个属性或方法，先看自己私有属性，如果没有就一级一级的沿着当前实例对象`__proto__`找所属类上的`prototype`是否有该属性或方法，否则再沿着当前实例的`__proto__`的`__proto__`....
>
> > **例子1**
> >
> > `f1.hasOwnProperty('getY')`的查找过程，实例的私有方法中找不到`hasOwnProperty`，所以沿着`f1`的`__proto__`找到了`Fn.prototype`，仍然找不到`hasOwnProperty`，再沿着`fFn.prototype`的`__proto__`找到了`Object.prototype`，找到了`hasOwnProperty`
> >
> > **例子2**
> >
> > `f1.constructor`，只有在函数的`prototype`才有`contructor`属性，`f1`为类的实例，并没有，但是可以沿着`f1.__proto__`可以找到`Fn.prototype`，最终拿到的是`Fn.prototype`的`constructor`，最后得到`f1.constructor`为`Fn`
> >
> > **例子3**
> >
> > `f1.getX()`，要观察两点，
> >
> > + `getX()`是谁的？（私有，共有）
> > + `this`的指向
> >   + 看函数执行前面是否有点，如果有点，点的前面是谁，方法中的`this`就是谁，没有就是`window/undefined`
> >   + `例子：f1.__proto__.getX()`，`f1.__proto__`中有`getX`，执行`getX()`，`console.log(this.x)`，`this`是看函数执行前有没有点，如果有点，点前面就是它的`this`，也就是`f1.__proto__`，在`f1.__proto__`中寻找`x`，没有找到，那么沿着`f1.__proto__`（也就是`Fn.prototype`）的`__proto__`找到`Object.prototype`，但是在`Object.prototype`上也找不到`x`，所以最后`this.x`为`undefined`
>
> 箭头函数有没有`__proto__`？
>
> > 有的，箭头函数虽然没有原型链，也就是没有`prototype`，但是有`__proto__`，因为不管怎么样，箭头函数都是对象，对象都有`__proto__`，如果不明确当前实例所对应的类，那么就是`Object`，它的`__proto__`指向`Object.prototype`



### 有/无参数`new`

```js
function c() {
  function Fn(x) {
    this.x = x
  }
  let f1 = new Fn(1);
  let f2 = new Fn;
  console.log(f1);
  console.log(f2);
}
c()
```

> `有参数new`和`无参数new`的区别：
>
> + `无参数new`无法传参，`有参数new`可以传递
> + 优先级不同，`有参数new`的优先级是19，`无参数new`的优先级是18，**有参比无参高**