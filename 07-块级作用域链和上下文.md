## 块级作用域链和上下文

### 新版浏览器(`IE11及以上`)有多惨？

> + **向前兼容ES3/ES5规范**
>   1. 判断体和函数体等不存在块级上下文，**只有全局和函数上下文**
>   2. 无论条件是否成立，带`function`的都要声明 + 定义
> + 向后兼容ES6规范
>   + 存在块级作用域，在大括号中的`let/const/function`，**都会被认为是块级作用域**
>   + 无论条件是否成立，带`function`的**只提前声明，不会提前定义**
> + **新版本浏览器**：因为要兼容ES3/ES6，代码块（`{}`）中的`函数声明`的变量提升，**在全局和块级作用域都有处理**。当**函数执行时再次遇到此行代码**，私有下不会再处理（已经处理过就不会再次处理了），但是浏览器会把当前代码之前的所有对`该函数`的操作，**映射给全局一份（其实就是把现在该变量的值赋值给全局的该变量）**，以此兼容ES3，但是它**后面的代码和全局没有任何关系**了



### 块级作用域链和上下文

>1. **上层上下文在进行函数执行的过程中，遇到了块级作用域后**
>2. `形成`一个全新的`块级私有上下文（EC(Block)）`，供代码执行
>3. 进`栈`执行
>  + 把全局上下文放到栈的`底部`
>  + 把自己的上下文放到栈的`顶部`
>4. 创建一个`块级私有变量对象(VO(Blcok))`
>5. 初始化作用域链`(scopeChain)`
>  - 作用域链组成：`<自己的私有上下文,自己的作用域（创建函数的时候的作用域，也就是scope）>`，如`<EC(Block)，EC(G)>`，始终存在链首部为自己的私有上下文，链尾为全局上下文
>  - 作用域链作用：`在私有上下文执行时`，私有上下文的属性和方法**优先**，如果未找到会一直沿着作用域查找，直到`EC(G)`，如果还未找到，则报错`undefined`
>6. 初始化`this`指向，**没有自己的`this`，用的是链的上层上下文**
>7. 初始化实参集合（`arguments`），**没有`arguments`**
>8. 形参赋值，**没有形参**
>9. 变量提升，如上**新版浏览器(`IE11及以上`)有多惨？**所述
>10. 代码执行
>11. 出`栈`



```js
var a = 0
if (true) {
  a = 1
  function a() { }
  a = 2
  console.log(a);
}
console.log(a);
```

>**各种浏览器的结果**
>
>+ `IE 5/7/8/9/10  ---  2 2`
>+ `IE 11  ---  2 function a(){}`
>+ `chrome  ---  2 1`



### 函数作用域和上下文的区别

> + 函数在哪创建的，**作用域就是谁**
>
> + 函数执行的环境，叫做**上下文**
