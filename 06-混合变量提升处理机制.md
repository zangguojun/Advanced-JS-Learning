## 混合变量提升处理机制

### `var`和`function`的变量提升

> **变量提升**：在当前上下文中（全局/私有/块级），JS代码执行之前，浏览器会提前处理一些事情，它是`词法解析`的一个环节。**只有ES3的`var`和`function`会变量提升，ES6中的`let`和`const`不会变量提升**
>
> **作用**：会把**当前上下文**中带有`var`关键词的进行提前的声明(`declare`)，声明之后默认值为`undefined`，带`function`关键词的进行提前的声明(`declare`)和定义(`defined`)。`var`和`function`的优先级一样高，所以是自上而下的声明或者定义。基于**`var`和`function`**在**全局上下文**的全局变量（VOG）会映射到全局对象（GO，`window`或者`global`）上一份，作为它的属性或者方法，并且这些属性会进行**双向绑定**，一个变量修改，另一个变量也会随之更改。**严格模式下也是如此**
>
> **意义**：让我们能在创建这个变量之前就使用这个变量而不报错。但是在项目中，最好使用函数表达式（`var func = function(){}`）来声明函数，因为这样只会声明不会定义，迫使在定义之后使用函数
>
> ```js
> var a = 10
> var a           //声明declare
> a = 10          //定义defined
> function b(){}  //声明declare + 定义defined
> ```
>
> **注意**：在定义函数表达式时，将匿名函数具名化后，仍然不能使用具名化后的名字，因为此时具名并**未**在当前上下文中创建，当函数执行时，所形成的函数私有上下文中，会把这个具名作为私有上下文的变量（可以用来`递归`，而不需要使用`严格模式`下`不支持`的`arguments.callee`，当然也能使用`var`过的变量名`func`，但是在某些情况下，不能通过`var`定义函数，可以使用上述方法，如`setTimeout`）
>
> ```js
> var func = function A(){
>   console.log(A,'[Function: A]');
>   console.log(func,'[Function: A]');
> }
> func()
> // console.log(A);//ReferenceError: A is not defined
> setTimeout(function B(){
>   console.log(B,'[Function: B]');
> }, 0);
> ```
>
> **多个同一变量的定义**：在同一个上下文，已经声明过的就**不会再次声明**，但是**会再次定义**，`function`和`var`是相通的，如下，此时的`var f`就不**会再次声明**，但是在代码执行阶段**会再次定义**。还有一个**注意点**就是，如果一个函数声明并且定义了，那么之后的代码执行阶段，就会直接跳过函数的代码块
>
> ```js
> function f() {}
> var f = function ff() {}
> ```
>
> ```js
> fn()
> function fn() {
>   console.log(1);
>  }
> fn()
> function fn() {
>   console.log(2);
> }
> fn()
> var fn = function fn() {
>   console.log(3);
> }
> fn()
> function fn() {
>   console.log(4);
> }
> fn()
> function fn() {
>   console.log(5);
> }
> fn()
> ```



### `let`和`const`的**非**变量提升

> 在`let`声明前，使用`let`报错：在代码执行阶段，因为此时log出来了`OK1`，但是没有log出来`OK2`，原因是在找不到`a`的时候，会继续向下查找（**但是此时不会向下执行任何代码，只是查找`let`是否定义了`a`**）是不是使用`let`定义了`a`，如果是，则报错`ReferenceError: Cannot access 'a' before initialization`，否则报错`ReferenceError: a is not defined`
>
> ```js
> console.log('OK1');
> console.log(a);
> console.log('OK2');
> let a = 12
> a = 13
> // OK1
> // ReferenceError: Cannot access 'a' before initialization
> ```
>
> `let`不允许重复声明，会在词法解析阶段进行判断。因为此时未log任何值，直接报错。
>
> ```js
> console.log('11111');
> let bbb = '123'
> console.log('22222');
> let bbb = '456'
> console.log('33333');
> // SyntaxError: Identifier 'bbb' has already been declared
> ```
>



### 条件中的变量提升

> 无论条件是否成立，都要进行变量提升
>
> 但是，在**新版本浏览器(`IE10`及以下)**中，条件中带`function`的，**只会提前声明，不会提前定义了**
>
> ```js
> console.log(b,funcb);
> if(false) {
> var b = 1
> function funcb(){}
> }
> console.log(b,funcb);
> 
> function funcc() {
> console.log(d,funcd);
> if(false) {
>  var d = 1
>  function funcd(){}
> }
> console.log(d,funcd);
> }
> funcc()
> // 5 5 5 3 3 3
> ```



#### 综合题

```js
var foo = 1
function bar() {
  if (!foo) {
    var foo = 10
  }
  console.log(foo, 10);
}
bar()
```

