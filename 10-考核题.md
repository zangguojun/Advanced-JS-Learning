#### 1

```js
let arr = [10.18, 0, 10, 25, 23]
arr = arr.map(parseInt)
console.log(arr);
```

> ```js
> // 10.18 0 10
> // 0     1 NaN
> // 10    2 2
> // 25    3 2
> // 23    4 11
> ```
>
> `radix`取：`0，[2, 36]`



#### 2

```js
var a = 10, b = 11, c = 12
function test(a) {
  a = 1     // => EC(a)私有
  var b = 2 // => EC(a)私有
  c = 3     // => EC(G)拥有
}
test(10)
console.log(a, b, c);
// 10 11 3
```



#### 3

```js
var a = 4
function b(x, y, a) {
  console.log(a, 3);
  arguments[2] = 10
  console.log(a, 10);
}
a = b(1, 2, 3)
console.log(a, undefined);
```

> 初始化`arguments`：**当函数中有处理`arguments`的步骤**，就需要考虑初始化`arguments`，`arguments`是函数内置实参集合，是一个类数组，形如`{0: 1,1: 2, 2: 3,length: 3}`
>
> + **在JS的非严格模式下**，函数中初始化`arguments`和形参赋值完成后， 浏览器会按照形参和`arguments`中的每一项建立**双向绑定（映射关系）**
>
> + **在JS的严格模式下**，并不会做任何操作
>
>   + ```js
>     var a = 4
>     function b(x, y, a) {
>       'use strict'
>       console.log(a, 3);
>       arguments[2] = 10
>       console.log(a, 3);
>     }
>     a = b(1, 2, 3)
>     console.log(a, undefined);
>     ```
>
>   
>
> **注意**：如果在参数传值中，没有传完整，那么`arguments`接收的**也是不完整的参数**，而且在之后**不会再改变**，这样`arguments`和参数传值**就没法一一对应**
>
> ```js
> function funcA(x, y, z) {
>   x = 100
>   console.log(arguments[0], 100);
> 
>   arguments[1] = 200
>   console.log(y, 200);
> 
>   z = 300
>   console.log(arguments[2], undefined);
> }
> 
> function funcB(x, y, z) {
>   x = 100
>   console.log(arguments[0], 100);
> 
>   arguments[1] = 200
>   console.log(y, 200);
> 
>   arguments[2] = 300
>   console.log(z, undefined);
> }
> funcA(10, 20)
> funcB(10, 20)
> ```
>
> > **实参集合和形参双向绑定（映射关系）**
> >
> > `x -> arguments[0]`
> >
> > `y -> arguments[1]`
> >
> > `z -> 没有，arguments只有两项`



#### 4

```js
{
  function foo() {}//*
  foo = 1
}
console.log(foo);

{
  function foo() {}
  foo = 1
  function foo() {}
}
console.log(foo);

{
  function foo() {}
  foo = 1
  function foo() {}
  foo = 2
}
console.log(foo);
```

> ##### **只考虑新版本浏览器，因为老版本浏览器，没有块级作用域**
>
> + **什么时候只是声明`let`和`function`？**
>   + **除函数题以外的大括号内**的`var`和`function`都会声明，新版本的浏览器不会定义函数。
> + **什么时候有块级作用域**
>   + 在代码执行的阶段，发现**除函数题以外的大括号内**有`let/const/function`，就会形成块级作用域
> + **标\*的部分**，索然此时的foo是私有的，但是为了兼容`ES3`，【本来在ES6想直接不管块级作用域里面的东西，即`不声明var和不声明也不定义function`，但是最终妥协了，折中处理了，`让var和function只是声明，function不定义`】，`foo`在全局中已经声明过，浏览器会把这行代码之前对`foo`的操作（**包含变量提升时候做的操作**）映射到全局一份（即，当再次遇到`function`函数块的时候，会把当前`foo`的值赋值给全局的`foo`）