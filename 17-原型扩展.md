## 原型扩展

```js
String.prototype.queryURLParams = function (key) {
  let obj = {}
  this.replace(/([^?&=#]+)=([^?&=#]+)/g, (_, $1, $2) => obj[$1] = $2)
  this.replace(/#([^?&=#]+)/g, (_, $1) => obj['_HASH'] = $1)
  return typeof key === "undefined" ? obj : obj[key]
}
let url = "http://www.zhufengpeixun.cn/?lx=1&from=wx#video";
console.log(url.queryURLParams('from'));
console.log(url.queryURLParams('_HASH'));
console.log(url.queryURLParams());
```

> **`this`必须是一个对象类型值**
>
> 所以这里的`this`是一个字符串对象，但是我们仍然可以直接把他当作`url`的字符串内存，因为`this`会在何时的情况下，调用`valueOf`方法返回它的**原始值**



```js
function b() {
  Number.prototype.MyHandleNum = function (num) {
    this.num = Number(num)
    return isNaN(num) ? 0 : num
  }
  Number.prototype.MyPlus = function (x) {
    console.log(this, '[Number: 8]');
    return this + this.MyHandleNum(x)
  }
  Number.prototype.MyMinus = function (x) {
    return this - this.MyHandleNum(x)
  }
  let n = 10
  console.log(n.MyMinus(2).MyPlus(2), 10);
}
b()
```

> `this`永远是对象数据类型
>
> 如果把`this.num`改为`let num`就会报错，`SyntaxError: Identifier 'num' has already been declared`，因为调用两次`MyHandleNum`就会在一个环境中用`let`定义两个`num`，侧面反应了两次运行在同一个上下文。



```js
function c() {
  let obj = {
    name: 'bu',
    age: 22
  }
  console.log(obj.__proto__ === Object.prototype);
  
  Object.prototype.AAA = function () { }
  for (const key in obj) {
    if (Object.hasOwnProperty.call(obj, key)) {
      const x = obj[key];
      console.log(x);
    }
  }
  for (const key in obj) {
    const x = obj[key];
    console.log(x);
  }
}
c()
```



> 自己在内置类的`prototype`上扩展的方法是可枚举的，但是在内置的方法是不可枚举的，所以如果不加`Object.hasOwnProperty`进行判断就会被遍历出来，而内置的方法就不会被遍历出来

